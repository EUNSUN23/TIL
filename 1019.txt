-배운것-

<FE 입문 기술면접 특강 #1.>


1회차(10/19:월)
- 1교시 : 함수 실행
- 2교시 : 함수 선언
- 3교시 : 실행컨텍스트
- 4교시 : 스코프

2회차(10/20:화)
- 1교시 : Prototype
- 2교시 : Class
- 3교시 : JS 네이이티브 객체의 구조
- 4교시 : DOM의 구조

3회차(10/22:목)
- 1교시 : 클로져란?
- 2교시 : 클로져의 활용
- 3교시 : this 결정되는 원리
- 4교시 : 내가 결정하는 this

기타 
- 객체 설정
- get과 set
- promise, async / await
- 모듈

-자바스크립트에 대해 어느정도 이해하고 있지만 더 잘 이해하고 싶고, 기술면접에 대비하기 위한 심화수업.
-강사님 : 정을수 

*프로그래밍적 사고방식
-컴퓨터에게 내가 원하는 바를 논리적으로 전달할수있는 능력(생각의 정리가 필요함)
-계속 문제를 만나고 해결하는 것이 왕도. 컴퓨터 언어 표현력이 풍부해져야한다. 

*회사에서는 알고리즘을 잘 짜는 사람을 원할까?

-알고리즘은 당연히 넘어야 할 기본 자격증같은것. 그러나 알고리즘을 꼭 잘하지 않더라도 언어에 대한 
이해와 관심이 높으면 플러스요인. 알고리즘은 이쪽 분야의 흥미와 별 상관 없이 답을 외우고 훈련하면 
잘하게 될 수도 있음. 

*알고리즘은 가장 핵심적인 몇가지 메커니즘을 깊게, 잘 짜보는 것으로 연습하자. 

*알고리즘면접은 모든 회사가 다 보지 않지만 기술면접은 모든 회사가 다 본다는 것.

*프론트엔드 - 웹, 안드로이드, ios 개발 등등.. 분야가 갈라짐. 여기서는 웹 기반 프론트엔드. 

*자바스크립트는 원래 브라우저 안에만 있었던 언어. html,css 정보를 동적으로 다뤄줬던 것. node.js가 자바스크립트를
os안에서 사용할 수 있게끔 했음. 개발 framework이 그래서 나오게 되었음. 

라이브러리 : 특정 기능 빌려다 쓰는 도서관 / 제이쿼리, 뷰
프레임웤: 프로그래밍적 틀 제공. /리액트, 뷰

*자바스크립트를 dom, cssom 에만 사용하는것은 아님. 

- 1교시 : 함수 실행

1. 실행컨텍스트

렌더링 엔진이 dom, cssom작업을
순차적으로 끝낸 후, script 태그를 만나서 자바스크립트 엔진으로부터
html,css조절사항(?)을 전달받는다. 렌더링엔진은 이를 화면에 painting한다. 

콜스택(callstack): 자바스크립트 정보뭉치를 트리형태로(key:value)저장해놓는 곳. 
배열이라고 할 수 있음. 자바스크립트는 이 정보를 하나씩 해치움(소비/처리한다/etc)

(자바스크립트 배열과는 다름. js배열은 c언어나 java에서 사용하는 배열과 다름)

웹브라우저에서 새 페이지를 열면(실행하면) 콜스택이 열리고, 0번째 실행컨텍스트가 생김. 
0번째 실행컨텍스트를 "글로벌 컨텍스트"(global context :gc) 라고 한다. (전체 프로그래밍에 필요한 
준비물 모아두는 곳 // alert 등 window객체가 들어있다. ) 

할당은 저장하는것, cpu는 이 저장한 것을 차례대로 꺼내서 처리해주는 것. 

*글로벌 컨텍스트 구성요소*

var gc = {

VO(variable object/변수모음객체) : 
window(GO: 전역객체):{
alert: ~~,
document:~~,
foo: function(){
[[call]] -> 함수내용 
[[scope]] 
}
전역에 선언된 변수(함수가 할당된 변수도 포함) : ~~, 
},
Scope: [], 
this: ~~,

}
  
함수 만드는 방식 : 리터럴방식, 선언방식 

var foo = function(){~~}

function foo(){~~} 

* 왜 컴파일 단계에서는 변수명만 저장하는지? : 이런 변수가 있다고 알려줘서 미리 공간
확보하기 위해서. 

타입스크립트: 자바스크립트 외 다른 언어들에서 하듯이 변수명을 미리 설정해 놓을 수 있음. 
(숫자면 숫자, 문자면 문자..)제약이 있기 때문에 더 엄밀하고 규격화된 flow를 돌릴 수 있음. 

bar()
foo()

var foo = function(){}; --> 위에서 실행하지 못함 (컴파일 단계에서 undefined, 실행 단계에서 실행되기때문에.)

function bar(){} --> 위에서 실행 가능. (호이스팅됨)  

: *****선언형으로 함수를 만들면 컴파일 단계에서부터 메모리상에 준비가 되어있음. 



** 콜스택이 어떻게 돌아가느냐에 따라 비선형/선형, 비동기/동기 로 나눠짐(비선형:비순서적/선형:순서적)

*함수 : 원하는 기능을 수행하기위해서 만들어짐. 
별도의 메모리주소를 만들어서 그 안에 실행할 내용을 문자열로 저장해 두고 원할 때
그 문자열을 객체화시켜서 실행하는것. 

/선언형으로 함수를 만들면 미리 준비하는 점이 좋지만 오해가 생길 수 있음.
(함수 실행 밑부분에 함수 만들어두고 까먹고 위에 똑같은 함수 또 만들수도 있고...
함수선언은 항상 실행 위에 있는 것이 좋다. 물론 상황에 따라서. )

**가비지 컬렉터가 종료된 함수를 콜스택 메모리상에서 없애지 못하게 하는 것이 클로져임. 

**전역변수는 gc에 브라우저 창을 닫을 때 까지 남아있기 때문에 gc메모리가 많아지면 좋지 않다.


var a = 5;
var b = 3;
	
	var foo2 = function(a,b){
	  return a+b;
	  }
	
	var foo = function(a,b){
	  function func2(a,b){
	    return a+b;
	    }
	    return func2(func);
	  }
	  
	  foo(a,b);

--> var 변수 = foo(a,b); 이렇게 저장해주거나, foo(a,b)(a,b) 해서 안의 함수까지
바로 실행해주지 않고 단순 foo(a,b);만 하면 func2값은 날아간다. 





-질문-