-배운것-

* map 사용해서 데이터를 화면에 출력하기.  // map의 첫번째 param은 요소, 두번째 param은 인덱스를 받는다. 
- 데이터1-데이터2 식으로 짝지을때는 이차원배열을 사용하거나( [[데이터1,데이터2],[데이터1,데이터2]].map~)
 혹은 객체 이용하기. (객체가 실무에서는 더 많이 쓰임) 

ex) [{데이터1:사과, 데이터2:맛있다}].map((v) => return <li>{v.데이터1}<b>{v.데이터2}</b></li>);

- 리액트에서 map 사용시,  
태그에 고유의 key값을 붙여줘야 한다. (리액트가 key값을 보고 같은 컴포넌트인지 아닌지를 판단하기때문에)

ex) <li key = {v.데이터1} + {v.데이터2}></li> 

==> 이런식으로 받은 인자로 '고유의'key값을 만들어줘야 한다. (화면상표시x)
	단, 인덱스값은 key값으로 쓰지 말것. 성능최적화할 때 문제가 된다. 
	(react에서 key를 기준으로 엘리먼트를 추가/삭제/수정 하기때문에 배열의 순서가 바뀌면 문제생김)


* 컴포넌트 분리와 props

--컴포넌트 분리 : 각 파트를 컴포넌트화시켜서 본문에 import할 수 있다. (보통 반복문 단위로 분리)
- 성능최적화에 도움이 됨
- 가독성 
- 재사용성

(코드가 길어지면 컴포넌트로 따로 분리하는 습관을 들이자.)

--props : 컴포넌트가 상속 받는 속성. params를 속성으로 받으면 컴포넌트 분리한 상태에서도 이 속성
사용 가능. (부모-자식관계처럼 상속가능. 관계가 깊어져서 증조할아버지-증손자 간에 상속이 필요할 때는 리덕스 등을 사용한다)  
ex)  {this.state.tries.map((v, i) => {
            return <Try value={v} index={i} />;
          })}


class Try extends Component {
  render() {
    return (
      <li key={v.data1 + i}>
        {v.data1}은 {v.data2}
      </li>
    );
  }
}

*리액트에서 주석 쓰기 
{/**/}

* class 메소드 정의할 때 화살표 함수를 쓰는 이유 : .bind(this)를 자동으로 해준다.


*리액트에서 배열에 push하면 바뀐것 감지 못함. // 렌더링안함. 
새로운 배열 선언해서 복사할것, 

ex) const arr1 = [];
    const arr2 = [...arr1, 1] ===> [1]

--> 변화로 감지해서 렌더링함.








u-demy : 영어 인프런. 